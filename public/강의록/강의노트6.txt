Component 중첩 시 state 전달

1. 그냥 props를 쓴다면 >> 최상위 컴포넌트부터 차례차례 props를 통해 전달

App에서 stock={stock} > Detail에서 findIndex로 해당 index 파악해서 stock={props.stock[index]} > 마지막 ProductStock 컴포넌트에서 props.stock으로 찾음
(Detail.js 참조)

만약 하위 컴포넌트에서 props로 가져온 상위 컴포넌트의 state를 변경하려면?
매우 간단하게 마찬가지로 useState()의 state변경 함수를 props 해와서 사용하면 된다.
App에서 stockChange={stockChange} 하면 Detail에서 props.stockChange()로 사용 가능

https://ko.reactjs.org/docs/render-props.html

=================================================================================================================================================

class에서 props를 사용하는 방법은 간단

마찬가지로 상위컴포넌트에서 <하위컴포넌트 보낼속성명={}>으로 보내고

constructor(props) {
    super(props)
}
로 생성자에서 가져온 뒤

해당 사용처에서
render(
    this.props.보낼속성명 으로 사용가능
);

그리고 하위 컴포넌트에서 상위컴포넌트의 state를 변경할 경우
상위컴포넌트에서
const stateChange = () => { this.setState() } 이렇게 state 수정 함수를 따로 생성한 뒤

<하위컴포넌트 stateChange={stateChange}> 이렇게 마찬가지로 함수를 보내줘서 처리하면 된다.

=================================================================================================================================================

cf ) Vue의 경우 마찬가지로 props를 그냥 쓴다면

데이터를 가져오는건 React와 마찬가지로 props를 몇단계 중첩시키면 됨

하위 컴포넌트에서 상위 컴포넌트의 state를 변경할 때 custom event를 사용  (마찬가지로 props는 readonly이기에 안됨)
>> 이건 react useState가 변경함수를 보낼 수 있어서 편하다 암튼
>> 암튼 하는 방법은
   하위컴포넌트 : @onclick="" 등의 이벤트 바인딩으로 @onclick="$emit('메시지명', 데이터)"로 상위컴포넌트에 메시지를 보낸다. (참고로 @는 v-on: 임)
   (만약 $emit을 methods:{}에 함수로 정리한다면 this.$emit으로 해당 컴포넌트의 emit임을 명확히 해야함)
   상위컴포넌트 : 해당 <하위컴포넌트/> 태그에 @메시지명="" 으로 JS 구문을 입력한다 (가져온 변경 데이터는 $event 변수에 오브젝트로 담겨있음)

문제는 컴포넌트 중첩시 custom event가 매우 복잡해질 수 있다는 것 (emit 하면서 보내는 데이터야 중간단계에서 $event.변수로 보내면 될테고)

+ ) vue slot (진짜 간단히 전송할 때나 + HTML 태그까지 함께 보내서 적용시킬때 (<span> 등))
props보다 좀 더 직관적으로 하위 컴포넌트에 state를 전송해서 '꽂을 때' 사용
>> 하위 컴포넌트에 해당 state가 입력될 장소를 <slot></slot>으로 지정한다.
>> 상위 컴포넌트에서는 해당 <하위컴포넌트>slot으로 꽂을 데이터</하위컴포넌트>로 넣으면 됨

근데 slot은 HTML 태그이기 때문에 속성 같은 곳에도 데이터를 꽂을 수 있는 props와 달리 그냥 태그처럼만 사용 가능
대신 slot으로 꽂을 데이터의 모든 내용이 넘어가기에 <span>등을 사용해 스타일등을 그대로 적용시켜 보낼 수도 있음

slot을 여러개 사용할 경우
>> 하위 컴포넌트에는 <slot name="슬롯명"></slot>으로 name 속성 지정 가능
>> 상위 컴포넌트에서는 <하위컴포넌트><template v-slot:슬롯명>slot으로 꽂을 데이터</template></하위컴포넌트>로 특정하여 꽂을 수 있다.

참고로 <slot :작명1="보낼데이터"></slot>로 상위컴포넌트의 <template v-slot:default="작명2">{{작명2.작명2}}</template>로 받을 수 있지만 그닥 쓸일이 없다


=================================================================================================================================================
=================================================================================================================================================

Context API : 컴포넌트가 많을 때 props를 좀 더 효율적으로 사용하는 방법
(props 중첩 등이 많아질 경우)

React 내장함수로 하위 컴포넌트들이 props가 없이도 상위 컴포넌트의 state를 공유할 수 있음

예를 들어 stock state의 context를 만든다면
1.
let stockContext = React.createContext();를 해당 state가 있는 상위컴포넌트의 JSX가 들어가는 함수 외부에 만들어줌 
createContext()은 같은 변수값을 공유할 범위를 생성함
2.
같은 값을 공유할 HTML의 범위를 위의 함수로 생성된 컴포넌트로 지정함
<stockContext.Provider></stockContext.Provider>
3.
해당 범위 지정 컴포넌트의 value 속성으로 공유하고자 하는 값을 지정
<stockContext.Provider value={ stock }></stockContext.Provider>
4.
해당 범위의 하위컴포넌트가 있는 파일에서
import { useContext } from 'react' 한 뒤,

let 변수 = useContext(범위 컨텍스트 컴포넌트명)
let stock = useContext(stockContext) 으로 가져와서 >> value에 넣은 state가 담겨있다.

해당 데이터를 공유 가능

if) 만약 해당 하위 컴포넌트를 다른 파일에 만들었을 경우

마찬가지로 위의 사용법 + createContext()로 생성한 범위를 export로 보내야한다.
export let 변수명 = React.createContext()로 한뒤 해당 컴포넌트 파일에서 import {변수명} from '상위컴포넌트경로'로 받아옴

간단한 데이터 전송은 props가 간단하지만
context 범위 안에 하위 컴포넌트가 여럿 중첩되면 context가 편함

만약 상위 컴포넌트의 state를 수정하는 경우 마찬가지로 useState로 생성된 변경함수도 같이 보내서 사용한다.
그리고 한번에 여러 데이터를 보내는 경우 <stockContext.Provider value={{stock: stock, stockChange: stockChange}}> 이렇게 오브젝트 형식으로 넣어
let stock = useContext(stockContext)을 한 뒤 stock.stock과 같이 뽑아서 사용하면 된다.

주의할 점은 가능한 컴포넌트를 감싸야함
<Route>등을 감싸다간 뒤에 라우팅이 안되거나 하는 등의 문제가 터질 수 있다.
(물론 광범위하게 여러 라우터를 감쌀 수도 있겠지만..)

=================================================================================================================================================
=================================================================================================================================================

Redux 라이브러리 : 모든 컴포넌트에서 state를 공유할 수 있는 통합 관리 공간을 생성한다고 생각
>> props를 쉽게 쓸수 있고 state(store) 관리가 용이하다

Tip: import 시 {}가 없는건 export default 된 것을 가져온다는 것

1.라이브러리 설치 + store 사용

npm install redux react-redux 로 두개의 라이브러리 설치

redux는 데이터를 엄격히 관리하는 기능
react-redux는 redux를 react에서 쓸수 있게 보조하는 기능

index.js에서
import { Provider } from 'react-redux'; 함
Provider 태그로 감싸진 모든 컴포넌트는 같은 state를 공유할 수 있으므로
<Provider><App/></Provider>로 루트 컴포넌트를 감싼다

다른 파일에 만들어 import하거나 index.js에 (store.js 참조 Provider 부분만 index.js에 둔다 / store에서 export 시킬 것은 createStore 변수)
import {createStore} from 'redux';
let store = createStore(() => {
    return [{}];로 스테이트를 넣는다. (Redux에서는 state가 아니라 store라고 부름)
});

그리고 <Provider store={store}>로 Provider 태그의 store 어트리뷰트로 위에서 공유하고자 하는 스테이트 저장소를 공유함 (Context API와 비슷한 역할을 하기에 생긴것도 비슷)

이후 사용할 컴포넌트에서

import { connect } from 'react-redux';

하단에 export defualt 컴포넌트를 주석처리하고

function 함수명(state) { // redux store의 데이터를 가져와 props로 변환해주는 함수
    return {
        productName : state.name

        혹은

        state : state로 전부 가져올 수 있음

    } // 오브젝트형으로 리턴
}
export default connect(함수명)(컴포넌트명); 으로 처리한다 (store 데이터가 props로 엮인채로 컴포넌트가 export됨)

connect()()이건 거의 라이브러리 사용법에 가까움 connect()가 함수를 return하기에

>> 컴포넌트에서 사용은 위에서 props로 변경되었다고 한 것처럼
props.state.~로


>>> 컴포넌트가 많아지고 깊어져도 props를 여러번 전송하지 않고 state를 직접 갖다 쓸 수 있다.


2. redux데이터 변경관리

store데이터를 수정하는 방법을 미리 정의하고 이에 의거한 방법으로만 수정가능하게 처리
reducer 함수를 사용한다.

위에서 store를 정의했던
import {createStore} from 'redux';
let store = createStore(() => {
    return [{}];로 스테이트를 넣는다. (Redux에서는 state가 아니라 store라고 부름)
});

이것을 다음과 같이 다시 세분화하여 정의한다.

let 초기값 = [
    {}, {}, {}
];

function reducer(state = 초기값, action) {
    return state
}

let store = createStore(reducer); 

(순서 중요)

Tip : 참고로 파라미터 안의 state=cart_store는 es6의 default parameter 신문법 | 다른 초기화를 하지 않으면 해당 파라미터의 값의 기본값을 대입연산자 왼쪽 항으로 지정한다.

이후 reducer를 다음과 같이 수정해 데이터 수정이 가능하게 함

function reducer(state=초기값, action) {
    if(action.type === '수정방법') {
        updatedState = [...state];
        updatedState >> 수정 코드

        return updatedState;
    } else {
        return state;
    }
}

이후 store 사용 컴포넌트에서
onClick={} 등의 이벤트에서 ()=>{props.dispatch({type : '수정방법'});} 으로 아까 지정한 수정방법을 이용하여 요청한다.

이런 redux는 대형 앱들에 적당함 컴포넌트와 state가 많아도 한번에 관리가 되기 때문에
특히 reducer로 데이터 수정에 대한 방법을 한 곳에 정리해 놓기 때문에 버그가 났을때 디버깅이 수월해짐

따라서 redux는 상태관리 라이브러리라고 함


이제 여러 state에 해당하는 store와 reducer가 필요한 경우
물론 store 한개에다 [{}[{{}}]] 뭐 이런식으로 다양히 넣을 수 있지만 너무 복잡해짐

그렇다면 해당 state와 reducer함수를 만든 뒤

import {combineReducers, createStore} from 'redux'를 한뒤

let store = createStore(combineReducers({ reducer1, reducer2, ...})) 이런식으로 넣어준 뒤 처리한다

이후 store에서 데이터를 뽑아 쓸때 위에서 combineReducers에서 reducer들을 object로 넣었으므로

function storeProps(state) {
    return{
        state1 : state.reducer1;
    }
}

이와 같이 뽑아서 저장해 사용한다.